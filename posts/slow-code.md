---
title: Slow Code
date: 2025-02-25
author: psu
---

I posted an idea on twitter a while back that I wanted to keep in the Intertubes, which is
one of the reasons that I don't delete my old twitter account. Then I realized I could
post it here instead of tediously moving it to every new "social" platform every time the
current one burns down.

This is the idea:

> Idea: Slow Code ... a non-profit dedicated to the idea of improving the software world
> by taking more time to write less code.

Here is a screen shot of it to prove the time stamp:

> <a href="images/slow-code.png"><img src="images/slow-code.png" width=400></a>

As a useless digression, another idea that I posted on twitter first was about [the
fog](./to-the-fog.html). So here is a screen shot of that to prove the timestamp:

> <a href="images/the-fog.png"><img src="images/the-fog.png" width=400></a>

Maybe soon I'll be able to delete the twitter after I carefully move all the screen shots
here. 

Anyway, the idea in _slow code_ is, of course, stolen from the idea behind _Slow Food_.
The main purpose of Slow Food is, to a first approximation, to apply this same idea to
food. That is, a way to treat food that in a way that pays due respect to the origins and
history of the dishes rather than just to how much of it you can sell at a profit.

Replace _food_ with _code_ and _poof_ you have _slow code_.

To me the remarkable thing is that the through line from _food_ to _code_ is pretty
direct. Scaling food operations to be large scale profit centers distorts the product,
often for the worst. Similarly, the realities of _making money_ from software, in many
ways, makes software worse. 

What we have learned in the 50 or so years that large companies have driven industrial
growth from software development is that no matter that they tell you at a large scale
what consumers of software are willing to _pay money_ for is _new_ features. There has to
be at least the appearance of constant forward evolution in order for a software product
to continue to generate more revenue. Software that has reached a stable state over a long
period of time, and is thus more reliable and dependable, is also a financial loser.

But there is even more to it. In order to keep people interested the cadence for new
things in a software product has to be short enough. Back in the day cycles of multiple
years for large products were not unheard of. These days though you need to do at least
one big release per year and then multiple small releases per year in order to keep the
train moving.

You see this across the entire landscape of software products. It's a constant grind to
make the product look "new" in various ways. The resulting pressure to create new features
and keep up with the evolution of your infrastructure leaves very little time for bug
fixing, stability improvements and any kind of general contemplation design refinements.

So I'd like there to be a way to slow this down and give everyone time to take a breather
and spend some time thinking and fixing things. This will improve the lives of programmers
because they can gain some piece of mind and escape an almost constant pressure for
releases. In theory it should also make life better for users because it would give
programmers time to fix those long standing annoying bugs that always fall by the wayside
when they are forced to do nothing but build new things. Maybe users can be made to
understand this. Maybe not.

It would be nice to have more time for these things sometimes though. Perhaps this is an
unrealistic ideal. But ah well. It's a good idea anyway.
